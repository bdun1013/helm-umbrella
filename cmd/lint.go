package cmd

import (
	"errors"
	"fmt"
	"io"
	"log"
	"strings"
	"sync"

	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
	"helm.sh/helm/v3/pkg/chart"
	"helm.sh/helm/v3/pkg/chart/loader"
	"helm.sh/helm/v3/pkg/cli"
	"helm.sh/helm/v3/pkg/cli/values"
	"helm.sh/helm/v3/pkg/getter"
	"helm.sh/helm/v3/pkg/lint/support"
)

var (
	settings = cli.New()
)

func init() {
	log.SetFlags(log.Lshortfile)
}

type Lint struct {
	Strict    bool
	Namespace string
}

type LintResult struct {
	TotalChartsLinted int
	Messages          []support.Message
	Errors            []error
}

// NewLint creates a new Lint object with the given configuration.
func NewLint() *Lint {
	return &Lint{}
}

func newLintCommand(out io.Writer) *cobra.Command {
	client := NewLint()
	valueOpts := &values.Options{}

	cmd := &cobra.Command{
		Use:   "lint [flags] CHART",
		Short: "examnies an umbrella chart for possible issues",
		RunE: func(cmd *cobra.Command, args []string) error {
			paths := []string{"."}
			if len(args) > 0 {
				paths = args
			}
			vals, err := valueOpts.MergeValues(getter.All(settings))
			if err != nil {
				return err
			}

			var message strings.Builder
			failed := 0

			for _, path := range paths {
				fmt.Fprintf(&message, "==> Linting %s\n", path)

				result, err := client.Run(path, vals)

				if err != nil {
					return err
				}

				// All the Errors that are generated by a chart
				// that failed a lint will be included in the
				// results.Messages so we only need to print
				// the Errors if there are no Messages.
				if len(result.Messages) == 0 {
					for _, err := range result.Errors {
						fmt.Fprintf(&message, "Error %s\n", err)
					}
				}

				for _, msg := range result.Messages {
					fmt.Fprintf(&message, "%s\n", msg)
				}

				if len(result.Errors) != 0 {
					failed++
				}

				// Adding extra new line here to break up the
				// results, stops this from being a big wall of
				// text and makes it easier to follow.
				fmt.Fprint(&message, "\n")
			}

			fmt.Fprintf(out, message.String())

			summary := fmt.Sprintf("%d chart(s) linted, %d chart(s) failed", len(paths), failed)
			if failed > 0 {
				return errors.New(summary)
			}
			fmt.Fprintln(out, summary)
			return nil
		},
	}

	f := cmd.Flags()
	f.BoolVar(&client.Strict, "strict", false, "fail on lint warnings")
	addValueOptionsFlags(f, valueOpts)

	return cmd
}

func addValueOptionsFlags(f *pflag.FlagSet, v *values.Options) {
	f.StringSliceVarP(&v.ValueFiles, "values", "f", []string{}, "specify values in a YAML file or a URL(can specify multiple)")
	f.StringArrayVar(&v.Values, "set", []string{}, "set values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)")
	f.StringArrayVar(&v.StringValues, "set-string", []string{}, "set STRING values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)")
	f.StringArrayVar(&v.FileValues, "set-file", []string{}, "set values from respective files specified via the command line (can specify multiple or separate values with commas: key1=path1,key2=path2)")
}

func (l *Lint) Run(path string, vals map[string]interface{}) (*LintResult, error) {

	lowestTolerance := support.ErrorSev
	if l.Strict {
		lowestTolerance = support.WarningSev
	}
	result := &LintResult{}
	linter, err := lintUmbrellaChart(path, vals, l.Namespace, l.Strict)
	if err != nil {
		result.Errors = append(result.Errors, err)
	}

	result.Messages = append(result.Messages, linter.Messages...)
	result.TotalChartsLinted++
	for _, msg := range linter.Messages {
		if msg.Severity >= lowestTolerance {
			result.Errors = append(result.Errors, msg.Err)
		}
	}
	return result, nil
}

func lintUmbrellaChart(path string, vals map[string]interface{}, namespace string, strict bool) (support.Linter, error) {
	linter := support.Linter{ChartDir: path}

	chart, err := loader.Load(path)
	if err != nil {
		return linter, err
	}

	linter.RunLinterRule(support.WarningSev, path, validateConflictingDependencyVersions(chart))

	return linter, nil
}

func validateConflictingDependencyVersions(c *chart.Chart) error {
	depChan := make(chan *chart.Chart)
	// map of chart dep name to a map of version to charts: name -> (version -> charts)
	depMap := make(map[string]map[string][]*chart.Chart)
	var wg sync.WaitGroup
	var errorMessage strings.Builder

	wg.Add(1)
	go func(metaChan chan *chart.Chart, wg *sync.WaitGroup) {
		wg.Wait()
		close(metaChan)
	}(depChan, &wg)

	go sendChartToChan(c, depChan, &wg)

	for dep := range depChan {
		depName := dep.Metadata.Name
		depVersion := dep.Metadata.Version

		if depMap[depName] == nil {
			depMap[depName] = make(map[string][]*chart.Chart)
		}

		if depMap[depName][depVersion] == nil {
			depMap[depName][depVersion] = make([]*chart.Chart, 0)
		}

		depMap[depName][depVersion] = append(depMap[depName][depVersion], dep)
	}

	for depName, depVersionMap := range depMap {
		if len(depVersionMap) > 1 {
			fmt.Fprintf(&errorMessage, "Conflicting versions of chart %s: %s", depName, formatDepVersionMap(depName, depVersionMap))
		}
	}

	if errorMessage.String() != "" {
		return errors.New(errorMessage.String())
	}

	return nil
}

func sendChartToChan(c *chart.Chart, metaChan chan *chart.Chart, wg *sync.WaitGroup) {
	defer wg.Done()
	metaChan <- c
	for _, dep := range c.Dependencies() {
		wg.Add(1)
		go sendChartToChan(dep, metaChan, wg)
	}
}

func formatDepVersionMap(depName string, depVersionMap map[string][]*chart.Chart) string {
	depVersionMessages := make([]string, 0)

	for depVersion, charts := range depVersionMap {
		key := depName + "@" + depVersion
		chartPaths := make([]string, 0)

		for _, chart := range charts {
			chartPaths = append(chartPaths, chart.Parent().ChartPath())
		}
		depVersionMessages = append(depVersionMessages, fmt.Sprintf("%s in [%s]", key, strings.Join(chartPaths, ", ")))
	}

	return strings.Join(depVersionMessages, ", ")

}
